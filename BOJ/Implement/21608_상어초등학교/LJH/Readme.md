## 🔎문제 설명
​
단순 구현 문제입니다.
​
조건이 굉장히 많고요. 하지만 문제를 차근차근 읽고, 경우의 수를 가지치기하면 쉽게 풀 수 있는 문제입니다.
​
### 💡주목해야 할 점
​
-   학생은 자신을 좋아할 수 없다.
-   인접한 칸의 정의는 기준칸에서 상하좌우 4방향이다.
-   자리를 결정하는 규칙이 3가지가 있다.
    1.  인접한 칸 내에서 좋아하는 학생이 가장 많은 칸으로 자리를 정합니다.
    2.  1번을 만족하는 칸이 여러 개라면, 인접하는 칸 중 비어있는 칸이 가장 많은 자리로 자리를 정합니다.
    3.  2번을 만족하는 칸이 여러개라면, 행의 번호가 가장 작은 칸, 그다음으로 열의 번호가 가장 작은 칸.
-   여기서 중요한 점은 (r,c)라면 r이 행이고, c가 열이라는 점입니다!
​
위 주목해야 할 점을 참고해서, 문제를 풀면 됩니다.
​
우선 각 학생별로 좋아하는 사람을 저장해야 합니다.
​
인접리스트를 통해서 저장했습니다.
​
p \[번호\]는 번호에 해당하는 학생이 좋아하는 학생들의 번호가 저장되어 있는 배열이 됩니다.
​
p \[4\]\[0\]=2, p \[4\]\[1\] = 5, p \[4\]\[2\]= 1, p \[4\]\[3\] =7  이런 식으로 저장되겠죠?
​
우선 입력제한을 보면 N의 크기가 그렇게 크지 않았기에 탐색을 위해 사용되는 2개의 배열을 사용했습니다.
​
탐색을 할 때마다 초기화해줬고, 첫 번째는 좋아하는 사람의 수를 저장하는 배열, 두 번째는 단순 비어있는 칸을 저장하는 배열입니다.
​
n\*n으로 모든 칸을 탐색합니다.
​
기준 칸에서 4방향으로 탐색을하고, 4방향 중 비어있는 칸의 개수를 계산하고, 좋아하는 사람이 있는 칸의 개수를 계산합니다.
​
여기서 좋아하는 사람의 칸의 개수와 비어있는 칸의 개수를 최댓값으로 계속 갱신해 줍니다.

![](https://blog.kakaocdn.net/dn/xGsuU/btseSatRq3m/UsWWcYWe0ZFZozVbUPMg41/img.png)
​
-   첫 번째로 좋아하는 사람의 칸수를 비교해 줍니다.(1번 조건)
    -   최댓값을 갱신한다면 좌표를 업데이트해 줍니다.
-   만약 좋아하는 사람의 수가 같다면 2번 조건을 검사합니다.
    -   최댓값을 갱신한다면 좌표를 업데이트해줍니다.
-   인접칸의 개수도 같다면, 3번 조건을 검사합니다.
    -   여기서는 행과 열이 가장 작은 자리가 선택됩니다.
​
여기서 max를 -1로 초기화해야 하는 이유에 대해서 설명해 드리겠습니다.
​
max가 0인 경우 만~~~ 약에 자리를 배치하다가 인접한 칸의 좋아하는 사람도 없고, 빈칸도 없는 경우가 분명히 생길 것입니다.
​
이러한 경우 mrow, mcol의 초기값인 (0,0)으로 배치되기에, 만약 (0,0)에 배치된 사람이 있다면 그 값을 덮어쓰기 때문에 반드시!!!
​
\-1로 초기화해야 합니다.
​
저는 0으로 초기화해서, 런타임에러(인덱스 에러)가 발생했습니다..ㅠ
​
이렇게 자리 배치를 모두 완료하면, 만족도를 계산하면 됩니다.
​
만족도 계산은 굉장히 간단하기 때문에, 생략하겠습니다.

## 😀느낀 점

-   문제가 길어서, 어려워 보이지만 차근차근 조건을 하나씩 가지치기하면 굉장히 쉬운 문제다.